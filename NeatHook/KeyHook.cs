using System;
using System.Security.Permissions;
using System.Windows.Forms;

namespace NeatHook
{
    public sealed class KeyHook : IMessageFilter, IDisposable
    {
        /// <summary>
        /// A handle to the window that will receive WM_HOTKEY messages generated by the hot key.
        /// </summary>
        public IntPtr Handle { get; }

        /// <summary>
        /// A normal application can use any value between 0x0000 and 0xBFFF as the ID but if you are
        /// writing a DLL, then you must use GlobalAddAtom to get a unique identifier for your hot key.
        /// </summary>
        public int Id { get; }

        public Keys Key { get; }

        public KeyModifiers Modifiers { get; }

        /// <summary>
        /// This constant could be found in WinUser.h if you installed Windows SDK. Each windows
        /// message has an identifier, 0x0312 means that the mesage is a WM_HOTKEY message.
        /// </summary>
        // ReSharper disable once InconsistentNaming
        private const int WM_HOTKEY = 0x0312;

        /// <summary>
        /// Specify whether this object is disposed.
        /// </summary>
        private bool disposed;

        /// <summary>
        /// Raise an event when the hotkey is pressed.
        /// </summary>
        internal Action<KeyHook> HotKeyPressed;

        internal KeyHook(IntPtr handle, int id, KeyModifiers modifiers, Keys key)
        {
            if (key == Keys.None && modifiers == KeyModifiers.None)
                throw new ArgumentException("The key and modifiers could not be None.");

            Handle = handle;
            Id = id;
            Modifiers = modifiers;
            Key = key;

            RegisterHotKey();

            // Adds a message filter to monitor Windows messages as they are routed to their destinations.
            Application.AddMessageFilter(this);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Filters out a message before it is dispatched.
        /// </summary>
        [PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
        public bool PreFilterMessage(ref Message m)
        {
            // The property WParam of Message is typically used to store small pieces of information.
            // In this scenario, it stores the ID.
            if (m.Msg == WM_HOTKEY
               && m.HWnd == Handle
               && m.WParam == (IntPtr)Id
               && HotKeyPressed != null)
            {
                // Raise the HotKeyPressed if it is an WM_HOTKEY message.
                HotKeyPressed(this);

                // True to filter the message and stop it from being dispatched.
                return true;
            }

            // Return false to allow the message to continue to the next filter or control.
            return false;
        }

        /// <summary>
        /// Unregister the hotkey.
        /// </summary>
        private void Dispose(bool disposing)
        {
            // Protect from being called multiple times.
            if (disposed)
                return;

            if (disposing)
            {
                // Removes a message filter from the message pump of the application.
                Application.RemoveMessageFilter(this);

                NativeMethods.UnregisterHotKey(Handle, Id);
            }

            disposed = true;
        }

        /// <summary>
        /// RegisterKey the hotkey.
        /// </summary>
        private void RegisterHotKey()
        {
            bool isKeyRegisterd = NativeMethods.RegisterHotKey(Handle, Id, Modifiers, Key);

            // If the operation failed, try to unregister the hotkey if the thread has registered it before.
            if (!isKeyRegisterd)
            {
                // IntPtr.Zero means the hotkey registered by the thread.
                NativeMethods.UnregisterHotKey(IntPtr.Zero, Id);

                // Try to register the hotkey again.
                isKeyRegisterd = NativeMethods.RegisterHotKey(Handle, Id, Modifiers, Key);

                // If the operation still failed, it means that the hotkey was already used in
                // another thread or process.
                if (!isKeyRegisterd)
                    throw new ApplicationException("The hotkey is in use");
            }
        }

        /// <summary>
        /// Unregisteres the hot key.
        /// </summary>
        public void Unregister()
        {
            NeatHook.UnregisterKey(Id);
        }
    }
}