using System;
using System.Security.Permissions;
using System.Windows.Forms;

namespace NeatHook
{
    public sealed class KeyHook : IMessageFilter, IDisposable
    {
        /// <summary>
        /// A handle to the window that will receive WM_HOTKEY messages generated by the hot key.
        /// </summary>
        internal IntPtr Handle { get; }

        /// <summary>
        /// A normal application can use any value between 0x0000 and 0xBFFF as the ID but if you are
        /// writing a DLL, then you must use GlobalAddAtom to get a unique identifier for your hot key.
        /// </summary>
        internal int Id { get; }

        internal Keys Key { get; }

        internal KeyModifiers Modifiers { get; }

        /// <summary>
        /// This constant could be found in WinUser.h if you installed Windows SDK. Each windows
        /// message has an identifier, 0x0312 means that the mesage is a WM_HOTKEY message.
        /// </summary>
        // ReSharper disable once InconsistentNaming
        private const int WM_HOTKEY = 0x0312;

        /// <summary>
        /// Specify whether this object is disposed.
        /// </summary>
        private bool disposed;

        /// <summary>
        /// Raise an event when the hotkey is pressed.
        /// </summary>
        public event EventHandler HotKeyPressed;

        internal KeyHook(IntPtr handle, int id, KeyModifiers modifiers, Keys key)
        {
            if (key == Keys.None || modifiers == KeyModifiers.None)
                throw new ArgumentException("The key or modifiers could not be None.");

            Handle = handle;
            Id = id;
            Modifiers = modifiers;
            Key = key;

            RegisterHotKey();

            // Adds a message filter to monitor Windows messages as they are routed to their destinations.
            Application.AddMessageFilter(this);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Filters out a message before it is dispatched.
        /// </summary>
        [PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
        public bool PreFilterMessage(ref Message m)
        {
            // The property WParam of Message is typically used to store small pieces of information.
            // In this scenario, it stores the ID.
            if (m.Msg == WM_HOTKEY
               && m.HWnd == Handle
               && m.WParam == (IntPtr)Id
               && HotKeyPressed != null)
            {
                // Raise the HotKeyPressed event if it is an WM_HOTKEY message.
                HotKeyPressed(this, EventArgs.Empty);

                // True to filter the message and stop it from being dispatched.
                return true;
            }

            // Return false to allow the message to continue to the next filter or control.
            return false;
        }

        /// <summary>
        /// Get the modifiers and key from the KeyData property of KeyEventArgs.
        /// </summary>
        /// <param name="keydata">
        /// The KeyData property of KeyEventArgs. The KeyData is a key in combination with modifiers.
        /// </param>
        /// <param name="key">The pressed key.</param>
        internal static KeyModifiers GetModifiers(Keys keydata, out Keys key)
        {
            key = keydata;
            var modifiers = KeyModifiers.None;

            // Check whether the keydata contains the CTRL modifier key. The value of Keys.Control is 131072.
            if ((keydata & Keys.Control) == Keys.Control)
            {
                modifiers |= KeyModifiers.Control;

                key = keydata ^ Keys.Control;
            }

            // Check whether the keydata contains the SHIFT modifier key. The value of Keys.Control
            // is 65536.
            if ((keydata & Keys.Shift) == Keys.Shift)
            {
                modifiers |= KeyModifiers.Shift;
                key = key ^ Keys.Shift;
            }

            // Check whether the keydata contains the ALT modifier key. The value of Keys.Control is 262144.
            if ((keydata & Keys.Alt) == Keys.Alt)
            {
                modifiers |= KeyModifiers.Alt;
                key = key ^ Keys.Alt;
            }

            // Check whether a key other than SHIFT, CTRL or ALT (Menu) is pressed.
            if (key == Keys.ShiftKey || key == Keys.ControlKey || key == Keys.Menu) key = Keys.None;

            return modifiers;
        }

        /// <summary>
        /// Unregister the hotkey.
        /// </summary>
        private void Dispose(bool disposing)
        {
            // Protect from being called multiple times.
            if (disposed)
                return;

            if (disposing)
            {
                // Removes a message filter from the message pump of the application.
                Application.RemoveMessageFilter(this);

                NativeMethods.UnregisterHotKey(Handle, Id);
            }

            disposed = true;
        }

        /// <summary>
        /// RegisterKey the hotkey.
        /// </summary>
        private void RegisterHotKey()
        {
            bool isKeyRegisterd = NativeMethods.RegisterHotKey(Handle, Id, Modifiers, Key);

            // If the operation failed, try to unregister the hotkey if the thread has registered it before.
            if (!isKeyRegisterd)
            {
                // IntPtr.Zero means the hotkey registered by the thread.
                NativeMethods.UnregisterHotKey(IntPtr.Zero, Id);

                // Try to register the hotkey again.
                isKeyRegisterd = NativeMethods.RegisterHotKey(Handle, Id, Modifiers, Key);

                // If the operation still failed, it means that the hotkey was already used in
                // another thread or process.
                if (!isKeyRegisterd)
                    throw new ApplicationException("The hotkey is in use");
            }
        }
    }
}